"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-activity-calendar";
exports.ids = ["vendor-chunks/react-activity-calendar"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-activity-calendar/build/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-activity-calendar/build/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar chroma = __webpack_require__(/*! chroma-js */ \"(ssr)/./node_modules/chroma-js/chroma.js\");\nvar dateFns = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/index.mjs\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction _interopDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nvar chroma__default = /*#__PURE__*/ _interopDefault(chroma);\nvar React__default = /*#__PURE__*/ _interopDefault(React);\nfunction _extends() {\n    return _extends = Object.assign ? Object.assign.bind() : function(n) {\n        for(var e = 1; e < arguments.length; e++){\n            var t = arguments[e];\n            for(var r in t)({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n        }\n        return n;\n    }, _extends.apply(null, arguments);\n}\nconst NAMESPACE = \"react-activity-calendar\";\nconst LABEL_MARGIN = 8; // px\nconst DEFAULT_MONTH_LABELS = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\"\n];\nconst DEFAULT_LABELS = {\n    months: DEFAULT_MONTH_LABELS,\n    weekdays: [\n        \"Sun\",\n        \"Mon\",\n        \"Tue\",\n        \"Wed\",\n        \"Thu\",\n        \"Fri\",\n        \"Sat\"\n    ],\n    totalCount: \"{{count}} activities in {{year}}\",\n    legend: {\n        less: \"Less\",\n        more: \"More\"\n    }\n};\nfunction useColorScheme() {\n    const [colorScheme, setColorScheme] = React.useState(\"light\");\n    const onChange = (event)=>setColorScheme(event.matches ? \"dark\" : \"light\");\n    React.useEffect(()=>{\n        const mediaQuery = window.matchMedia(\"(prefers-color-scheme: dark)\");\n        setColorScheme(mediaQuery.matches ? \"dark\" : \"light\");\n        mediaQuery.addEventListener(\"change\", onChange);\n        return ()=>{\n            mediaQuery.removeEventListener(\"change\", onChange);\n        };\n    }, []);\n    return colorScheme;\n}\nfunction useIsClient() {\n    const [isClient, setClient] = React.useState(false);\n    React.useEffect(()=>{\n        setClient(true);\n    }, []);\n    return isClient;\n}\nconst query = \"(prefers-reduced-motion: reduce)\";\nfunction usePrefersReducedMotion() {\n    const [prefersReducedMotion, setPrefersReducedMotion] = React.useState(true);\n    React.useEffect(()=>{\n        const mediaQuery = window.matchMedia(query);\n        setPrefersReducedMotion(mediaQuery.matches);\n        const onChange = (event)=>{\n            setPrefersReducedMotion(event.matches);\n        };\n        mediaQuery.addEventListener(\"change\", onChange);\n        return ()=>{\n            mediaQuery.removeEventListener(\"change\", onChange);\n        };\n    }, []);\n    return prefersReducedMotion;\n}\nfunction styleInject(css, ref) {\n    if (ref === void 0) ref = {};\n    var insertAt = ref.insertAt;\n    if (typeof document === \"undefined\") {\n        return;\n    }\n    var head = document.head || document.getElementsByTagName(\"head\")[0];\n    var style = document.createElement(\"style\");\n    style.type = \"text/css\";\n    if (insertAt === \"top\") {\n        if (head.firstChild) {\n            head.insertBefore(style, head.firstChild);\n        } else {\n            head.appendChild(style);\n        }\n    } else {\n        head.appendChild(style);\n    }\n    if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        style.appendChild(document.createTextNode(css));\n    }\n}\nvar css_248z = \".styles-module_container__GBNxC {\\n  width: max-content; /* Calendar should not grow */\\n  max-width: 100%; /* Do not remove - flexbox parents */\\n  display: flex;\\n  flex-direction: column;\\n  gap: 8px;\\n}\\n\\n.styles-module_container__GBNxC rect {\\n  stroke: rgba(0, 0, 0, 0.08);\\n  stroke-width: 1px;\\n  shape-rendering: geometricPrecision;\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  .styles-module_container__GBNxC rect {\\n    stroke: rgba(255, 255, 255, 0.04);\\n  }\\n}\\n\\n.styles-module_scrollContainer__-bJC8 {\\n  max-width: 100%;\\n  overflow-x: auto;\\n  overflow-y: hidden;\\n}\\n\\n.styles-module_calendar__sT1ND {\\n  display: block; /* SVGs are inline-block by default */\\n  overflow: visible; /* Weekday labels are rendered left of the container */\\n}\\n\\n.styles-module_calendar__sT1ND text {\\n  fill: currentColor;\\n}\\n\\n.styles-module_footer__ZQ-Bl {\\n  display: flex;\\n  flex-wrap: wrap;\\n  gap: 4px 16px;\\n  white-space: nowrap;\\n}\\n\\n.styles-module_legendColors__kFY2e {\\n  margin-left: auto;\\n  display: flex;\\n  align-items: center;\\n  gap: 3px;\\n}\\n\\n@keyframes styles-module_loadingAnimation__V0w3h {\\n  0% {\\n    fill: var(--react-activity-calendar-loading);\\n  }\\n  50% {\\n    fill: var(--react-activity-calendar-loading-active);\\n  }\\n  100% {\\n    fill: var(--react-activity-calendar-loading);\\n  }\\n}\\n\";\nvar styles = {\n    \"container\": \"styles-module_container__GBNxC\",\n    \"scrollContainer\": \"styles-module_scrollContainer__-bJC8\",\n    \"calendar\": \"styles-module_calendar__sT1ND\",\n    \"footer\": \"styles-module_footer__ZQ-Bl\",\n    \"legendColors\": \"styles-module_legendColors__kFY2e\",\n    \"loadingAnimation\": \"styles-module_loadingAnimation__V0w3h\"\n};\nstyleInject(css_248z);\nfunction groupByWeeks(activities, weekStart = 0 // 0 = Sunday\n) {\n    if (activities.length === 0) {\n        return [];\n    }\n    const normalizedActivities = fillHoles(activities);\n    // Determine the first date of the calendar. If the first date is not the\n    // set start weekday, the selected weekday one week earlier is used.\n    const firstDate = dateFns.parseISO(normalizedActivities[0].date);\n    const firstCalendarDate = dateFns.getDay(firstDate) === weekStart ? firstDate : dateFns.subWeeks(dateFns.nextDay(firstDate, weekStart), 1);\n    // To correctly group activities by week, it is necessary to left-pad the list\n    // because the first date might not be set start weekday.\n    const paddedActivities = [\n        ...Array(dateFns.differenceInCalendarDays(firstDate, firstCalendarDate)).fill(undefined),\n        ...normalizedActivities\n    ];\n    const numberOfWeeks = Math.ceil(paddedActivities.length / 7);\n    // Finally, group activities by week\n    return Array(numberOfWeeks).fill(undefined).map((_, weekIndex)=>paddedActivities.slice(weekIndex * 7, weekIndex * 7 + 7));\n}\n/**\n * The calendar expects a continuous sequence of days,\n * so fill gaps with empty activity data.\n */ function fillHoles(activities) {\n    const dateMap = {};\n    for (const activity of activities){\n        dateMap[activity.date] = activity;\n    }\n    return dateFns.eachDayOfInterval({\n        start: dateFns.parseISO(activities[0].date),\n        end: dateFns.parseISO(activities[activities.length - 1].date)\n    }).map((day)=>{\n        const date = dateFns.formatISO(day, {\n            representation: \"date\"\n        });\n        if (dateMap[date]) {\n            return dateMap[date];\n        }\n        return {\n            date,\n            count: 0,\n            level: 0\n        };\n    });\n}\nfunction getMonthLabels(weeks, monthNames = DEFAULT_MONTH_LABELS) {\n    return weeks.reduce((labels, week, weekIndex)=>{\n        const firstActivity = week.find((activity)=>activity !== undefined);\n        if (!firstActivity) {\n            throw new Error(`Unexpected error: Week ${weekIndex + 1} is empty: [${week}].`);\n        }\n        const month = monthNames[dateFns.getMonth(dateFns.parseISO(firstActivity.date))];\n        const prevLabel = labels[labels.length - 1];\n        if (weekIndex === 0 || prevLabel.label !== month) {\n            return [\n                ...labels,\n                {\n                    weekIndex,\n                    label: month\n                }\n            ];\n        }\n        return labels;\n    }, []).filter(({ weekIndex }, index, labels)=>{\n        // Labels should only be shown if there is \"enough\" space (data).\n        // This is a naive implementation that does not take the block size,\n        // font size etc. into account.\n        const minWeeks = 3;\n        // Skip the first month label if there is not enough space to the next one.\n        if (index === 0) {\n            return labels[1] && labels[1].weekIndex - weekIndex >= minWeeks;\n        }\n        // Skip the last month label the there is not enough data in that month to\n        // avoid overflowing the calendar on the right.\n        if (index === labels.length - 1) {\n            return weeks.slice(weekIndex).length >= minWeeks;\n        }\n        return true;\n    });\n}\nfunction getClassName(name, styles) {\n    if (styles) {\n        return `${NAMESPACE}__${name} ${styles}`;\n    }\n    return `${NAMESPACE}__${name}`;\n}\nfunction generateEmptyData() {\n    const year = new Date().getFullYear();\n    const days = dateFns.eachDayOfInterval({\n        start: new Date(year, 0, 1),\n        end: new Date(year, 11, 31)\n    });\n    return days.map((date)=>({\n            date: dateFns.formatISO(date, {\n                representation: \"date\"\n            }),\n            count: 0,\n            level: 0\n        }));\n}\nfunction maxWeekdayLabelLength(firstWeek, weekStart, labels, fontSize) {\n    return firstWeek.reduce((maxLength, _, index)=>{\n        if (index % 2 !== 0) {\n            const dayIndex = (index + weekStart) % 7;\n            const curLength = Math.ceil(calcTextDimensions(labels[dayIndex], fontSize).width);\n            return Math.max(maxLength, curLength);\n        }\n        return maxLength;\n    }, 0);\n}\nfunction calcTextDimensions(text, fontSize) {\n    if (typeof document === \"undefined\" || \"undefined\" === \"undefined\") {\n        throw new Error(\"calcTextDimensions() requires browser APIs\");\n    }\n    if (fontSize < 1) {\n        throw new RangeError(\"fontSize must be positive\");\n    }\n    if (text.length === 0) {\n        return {\n            width: 0,\n            height: 0\n        };\n    }\n    const namespace = \"http://www.w3.org/2000/svg\";\n    const svg = document.createElementNS(namespace, \"svg\");\n    svg.style.position = \"absolute\";\n    svg.style.visibility = \"hidden\";\n    svg.style.fontFamily = window.getComputedStyle(document.body).fontFamily;\n    svg.style.fontSize = `${fontSize}px`;\n    const textNode = document.createElementNS(namespace, \"text\");\n    textNode.textContent = text;\n    svg.appendChild(textNode);\n    document.body.appendChild(svg);\n    const boundingBox = textNode.getBBox();\n    document.body.removeChild(svg);\n    return {\n        width: boundingBox.width,\n        height: boundingBox.height\n    };\n}\nfunction createTheme(input, size = 5) {\n    const defaultTheme = createDefaultTheme(size);\n    if (input) {\n        validateTheme(input, size);\n        input.light = input.light ?? defaultTheme.light;\n        input.dark = input.dark ?? defaultTheme.dark;\n        return {\n            light: isColorScale(input.light, size) ? input.light : createColorScale(input.light, size),\n            dark: isColorScale(input.dark, size) ? input.dark : createColorScale(input.dark, size)\n        };\n    }\n    return defaultTheme;\n}\nfunction createDefaultTheme(size) {\n    return {\n        light: createColorScale([\n            \"hsl(0, 0%, 92%)\",\n            \"hsl(0, 0%, 26%)\"\n        ], size),\n        dark: createColorScale([\n            \"hsl(0, 0%, 20%)\",\n            \"hsl(0, 0%, 92%)\"\n        ], size)\n    };\n}\nfunction validateTheme(input, size) {\n    if (typeof input !== \"object\" || input.light === undefined && input.dark === undefined) {\n        throw new Error(`The theme object must contain at least one of the fields \"light\" and \"dark\" with exactly 2 or ${size} colors respectively.`);\n    }\n    if (input.light) {\n        const { length } = input.light;\n        if (length !== 2 && length !== size) {\n            throw new Error(`theme.light must contain exactly 2 or ${size} colors, ${length} passed.`);\n        }\n    }\n    if (input.dark) {\n        const { length } = input.dark;\n        if (length !== 2 && length !== size) {\n            throw new Error(`theme.dark must contain exactly 2 or ${size} colors, ${length} passed.`);\n        }\n    }\n}\nfunction isColorScale(colors, size) {\n    const invalidColor = colors.find((color)=>!chroma__default.default.valid(color));\n    if (invalidColor) {\n        throw new Error(`Invalid color \"${invalidColor}\" passed. All CSS color formats are accepted.`);\n    }\n    return colors.length === size;\n}\nfunction createColorScale(colors, size) {\n    return chroma__default.default.scale(colors).mode(\"lch\").colors(size);\n}\nconst ActivityCalendar = ({ data, blockMargin = 4, blockRadius = 2, blockSize = 12, colorScheme = undefined, eventHandlers = {}, fontSize = 14, hideColorLegend = false, hideMonthLabels = false, hideTotalCount = false, labels: labelsProp = undefined, maxLevel = 4, loading = false, renderBlock = undefined, showWeekdayLabels = false, style: styleProp = {}, theme: themeProp = undefined, totalCount: totalCountProp = undefined, weekStart = 0 // Sunday\n })=>{\n    maxLevel = Math.max(1, maxLevel);\n    const theme = createTheme(themeProp, maxLevel + 1);\n    const systemColorScheme = useColorScheme();\n    const colorScale = theme[colorScheme ?? systemColorScheme];\n    const useAnimation = !usePrefersReducedMotion();\n    // Calculating the weekday label offset only works in the browser.\n    // So disable SSR in this case.\n    const isClient = useIsClient();\n    if (showWeekdayLabels && !isClient) {\n        return null;\n    }\n    if (loading) {\n        data = generateEmptyData();\n    }\n    if (data.length === 0) {\n        return null;\n    }\n    const year = dateFns.getYear(dateFns.parseISO(data[0]?.date));\n    const weeks = groupByWeeks(data, weekStart);\n    const labels = Object.assign({}, DEFAULT_LABELS, labelsProp);\n    const labelHeight = hideMonthLabels ? 0 : fontSize + LABEL_MARGIN;\n    const weekdayLabelOffset = showWeekdayLabels ? maxWeekdayLabelLength(weeks[0], weekStart, labels.weekdays, fontSize) + LABEL_MARGIN : undefined;\n    function getDimensions() {\n        return {\n            width: weeks.length * (blockSize + blockMargin) - blockMargin,\n            height: labelHeight + (blockSize + blockMargin) * 7 - blockMargin\n        };\n    }\n    function getEventHandlers(activity) {\n        return Object.keys(eventHandlers).reduce((handlers, key)=>({\n                ...handlers,\n                [key]: (event)=>eventHandlers[key]?.(event)(activity)\n            }), {});\n    }\n    function renderCalendar() {\n        return weeks.map((week, weekIndex)=>week.map((activity, dayIndex)=>{\n                if (!activity) {\n                    return null;\n                }\n                if (activity.level < 0 || activity.level > maxLevel) {\n                    throw new RangeError(`Provided activity level ${activity.level} for ${activity.date} is out of range. It must be between 0 and ${maxLevel}.`);\n                }\n                const style = loading && useAnimation ? {\n                    animation: `${styles.loadingAnimation} 1.75s ease-in-out infinite`,\n                    animationDelay: `${weekIndex * 20 + dayIndex * 20}ms`\n                } : undefined;\n                const block = /*#__PURE__*/ React__default.default.createElement(\"rect\", _extends({}, getEventHandlers(activity), {\n                    x: 0,\n                    y: labelHeight + (blockSize + blockMargin) * dayIndex,\n                    width: blockSize,\n                    height: blockSize,\n                    rx: blockRadius,\n                    ry: blockRadius,\n                    fill: colorScale[activity.level],\n                    \"data-date\": activity.date,\n                    \"data-level\": activity.level,\n                    style: style\n                }));\n                return /*#__PURE__*/ React__default.default.createElement(React.Fragment, {\n                    key: activity.date\n                }, renderBlock ? renderBlock(block, activity) : block);\n            })).map((week, x)=>/*#__PURE__*/ React__default.default.createElement(\"g\", {\n                key: x,\n                transform: `translate(${(blockSize + blockMargin) * x}, 0)`\n            }, week));\n    }\n    function renderFooter() {\n        if (hideTotalCount && hideColorLegend) {\n            return null;\n        }\n        const totalCount = typeof totalCountProp === \"number\" ? totalCountProp : data.reduce((sum, activity)=>sum + activity.count, 0);\n        return /*#__PURE__*/ React__default.default.createElement(\"footer\", {\n            className: getClassName(\"footer\", styles.footer),\n            style: {\n                marginLeft: weekdayLabelOffset\n            }\n        }, loading && /*#__PURE__*/ React__default.default.createElement(\"div\", null, \"\\xa0\"), !loading && !hideTotalCount && /*#__PURE__*/ React__default.default.createElement(\"div\", {\n            className: getClassName(\"count\")\n        }, labels.totalCount ? labels.totalCount.replace(\"{{count}}\", String(totalCount)).replace(\"{{year}}\", String(year)) : `${totalCount} activities in ${year}`), !loading && !hideColorLegend && /*#__PURE__*/ React__default.default.createElement(\"div\", {\n            className: getClassName(\"legend-colors\", styles.legendColors)\n        }, /*#__PURE__*/ React__default.default.createElement(\"span\", {\n            style: {\n                marginRight: \"0.4em\"\n            }\n        }, labels?.legend?.less ?? \"Less\"), Array(maxLevel + 1).fill(undefined).map((_, level)=>/*#__PURE__*/ React__default.default.createElement(\"svg\", {\n                width: blockSize,\n                height: blockSize,\n                key: level\n            }, /*#__PURE__*/ React__default.default.createElement(\"rect\", {\n                width: blockSize,\n                height: blockSize,\n                fill: colorScale[level],\n                rx: blockRadius,\n                ry: blockRadius\n            }))), /*#__PURE__*/ React__default.default.createElement(\"span\", {\n            style: {\n                marginLeft: \"0.4em\"\n            }\n        }, labels?.legend?.more ?? \"More\")));\n    }\n    function renderLabels() {\n        if (!showWeekdayLabels && hideMonthLabels) {\n            return null;\n        }\n        return /*#__PURE__*/ React__default.default.createElement(React__default.default.Fragment, null, showWeekdayLabels && /*#__PURE__*/ React__default.default.createElement(\"g\", {\n            className: getClassName(\"legend-weekday\")\n        }, weeks[0].map((_, index)=>{\n            if (index % 2 === 0) {\n                return null;\n            }\n            const dayIndex = (index + weekStart) % 7;\n            return /*#__PURE__*/ React__default.default.createElement(\"text\", {\n                x: -LABEL_MARGIN,\n                y: labelHeight + (blockSize + blockMargin) * index + blockSize / 2,\n                dominantBaseline: \"middle\",\n                textAnchor: \"end\",\n                key: index\n            }, labels.weekdays[dayIndex]);\n        })), !hideMonthLabels && /*#__PURE__*/ React__default.default.createElement(\"g\", {\n            className: getClassName(\"legend-month\")\n        }, getMonthLabels(weeks, labels.months).map(({ label, weekIndex })=>/*#__PURE__*/ React__default.default.createElement(\"text\", {\n                x: (blockSize + blockMargin) * weekIndex,\n                dominantBaseline: \"hanging\",\n                key: weekIndex\n            }, label))));\n    }\n    const { width, height } = getDimensions();\n    const containerStyles = {\n        fontSize,\n        ...useAnimation && {\n            [`--${NAMESPACE}-loading`]: colorScale[0],\n            [`--${NAMESPACE}-loading-active`]: colorScheme === \"light\" ? chroma__default.default(colorScale[0]).darken(0.3).hex() : chroma__default.default(colorScale[0]).brighten(0.25).hex()\n        }\n    };\n    return /*#__PURE__*/ React__default.default.createElement(\"article\", {\n        className: `${NAMESPACE} ${styles.container}`,\n        style: {\n            ...styleProp,\n            ...containerStyles\n        }\n    }, /*#__PURE__*/ React__default.default.createElement(\"div\", {\n        className: getClassName(\"scroll-container\", styles.scrollContainer)\n    }, /*#__PURE__*/ React__default.default.createElement(\"svg\", {\n        width: width,\n        height: height,\n        viewBox: `0 0 ${width} ${height}`,\n        className: getClassName(\"calendar\", styles.calendar),\n        style: {\n            marginLeft: weekdayLabelOffset\n        }\n    }, !loading && renderLabels(), renderCalendar())), renderFooter());\n};\nconst Skeleton = (props)=>/*#__PURE__*/ React__default.default.createElement(ActivityCalendar, _extends({\n        data: []\n    }, props));\nexports.Skeleton = Skeleton;\nexports[\"default\"] = ActivityCalendar; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtYWN0aXZpdHktY2FsZW5kYXIvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTyxNQUFNQSxZQUFZO0FBQ2xCLE1BQU1DLGVBQWUsR0FBRTtBQUV2QixNQUFNQyx1QkFBdUI7SUFDbEM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFTSxNQUFNQyxpQkFBaUI7SUFDNUJDLFFBQVFGO0lBQ1JHLFVBQVU7UUFBQztRQUFPO1FBQU87UUFBTztRQUFPO1FBQU87UUFBTztLQUFNO0lBQzNEQyxZQUFZO0lBQ1pDLFFBQVE7UUFDTkMsTUFBTTtRQUNOQyxNQUFNO0lBQ1I7QUFDRjtBQ3hCTyxTQUFTQztJQUNkLE1BQU0sQ0FBQ0MsYUFBYUMsZUFBZSxHQUFHQyxNQUFBQSxRQUFRLENBQW1CO0lBRWpFLE1BQU1DLFdBQVlDLENBQUFBLFFBQStCSCxlQUFlRyxNQUFNQyxPQUFPLEdBQUcsU0FBUztJQUV6RkMsTUFBQUEsU0FBUyxDQUFDO1FBQ1IsTUFBTUMsYUFBYUMsT0FBT0MsVUFBVSxDQUFDO1FBQ3JDUixlQUFlTSxXQUFXRixPQUFPLEdBQUcsU0FBUztRQUU3Q0UsV0FBV0csZ0JBQWdCLENBQUMsVUFBVVA7UUFFdEMsT0FBTztZQUNMSSxXQUFXSSxtQkFBbUIsQ0FBQyxVQUFVUjs7T0FFMUMsRUFBRTtJQUVMLE9BQU9IO0FBQ1Q7QUNqQk8sU0FBU1k7SUFDZCxNQUFNLENBQUNDLFVBQVVDLFVBQVUsR0FBR1osTUFBQUEsUUFBUSxDQUFDO0lBRXZDSSxNQUFBQSxTQUFTLENBQUM7UUFDUlEsVUFBVTtPQUNULEVBQUU7SUFFTCxPQUFPRDtBQUNUO0FDUkEsTUFBTUUsUUFBUTtBQUVQLFNBQVNDO0lBQ2QsTUFBTSxDQUFDQyxzQkFBc0JDLHdCQUF3QixHQUFHaEIsTUFBQUEsUUFBUSxDQUFDO0lBRWpFSSxNQUFB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Q3BDLE1BQU07SUFBRyxHQUFLZ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW9fd2Vic2l0ZS8uLi9zcmMvY29uc3RhbnRzLnRzP2IxM2UiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvX3dlYnNpdGUvLi4vc3JjL2hvb2tzL3VzZUNvbG9yU2NoZW1lLnRzPzc5YzciLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvX3dlYnNpdGUvLi4vc3JjL2hvb2tzL3VzZUlzQ2xpZW50LnRzPzdlNTYiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvX3dlYnNpdGUvLi4vc3JjL2hvb2tzL3VzZVByZWZlcnNSZWR1Y2VkTW90aW9uLnRzPzc5OWMiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvX3dlYnNpdGUvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3N0eWxlLWluamVjdEAwLjMuMC9ub2RlX21vZHVsZXMvc3R5bGUtaW5qZWN0L2Rpc3Qvc3R5bGUtaW5qZWN0LmVzLmpzPzYzMGUiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvX3dlYnNpdGUvLi4vc3JjL3V0aWxzL2NhbGVuZGFyLnRzP2FiZTciLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvX3dlYnNpdGUvLi4vc3JjL3V0aWxzL3RoZW1lLnRzPzc2ZDYiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvX3dlYnNpdGUvLi4vc3JjL2NvbXBvbmVudC9BY3Rpdml0eUNhbGVuZGFyLnRzeD80YjgzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBOQU1FU1BBQ0UgPSAncmVhY3QtYWN0aXZpdHktY2FsZW5kYXInO1xuZXhwb3J0IGNvbnN0IExBQkVMX01BUkdJTiA9IDg7IC8vIHB4XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX01PTlRIX0xBQkVMUyA9IFtcbiAgJ0phbicsXG4gICdGZWInLFxuICAnTWFyJyxcbiAgJ0FwcicsXG4gICdNYXknLFxuICAnSnVuJyxcbiAgJ0p1bCcsXG4gICdBdWcnLFxuICAnU2VwJyxcbiAgJ09jdCcsXG4gICdOb3YnLFxuICAnRGVjJyxcbl07XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0xBQkVMUyA9IHtcbiAgbW9udGhzOiBERUZBVUxUX01PTlRIX0xBQkVMUyxcbiAgd2Vla2RheXM6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gIHRvdGFsQ291bnQ6ICd7e2NvdW50fX0gYWN0aXZpdGllcyBpbiB7e3llYXJ9fScsXG4gIGxlZ2VuZDoge1xuICAgIGxlc3M6ICdMZXNzJyxcbiAgICBtb3JlOiAnTW9yZScsXG4gIH0sXG59O1xuIiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbG9yU2NoZW1lKCkge1xuICBjb25zdCBbY29sb3JTY2hlbWUsIHNldENvbG9yU2NoZW1lXSA9IHVzZVN0YXRlPCdsaWdodCcgfCAnZGFyayc+KCdsaWdodCcpO1xuXG4gIGNvbnN0IG9uQ2hhbmdlID0gKGV2ZW50OiBNZWRpYVF1ZXJ5TGlzdEV2ZW50KSA9PiBzZXRDb2xvclNjaGVtZShldmVudC5tYXRjaGVzID8gJ2RhcmsnIDogJ2xpZ2h0Jyk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBtZWRpYVF1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKTtcbiAgICBzZXRDb2xvclNjaGVtZShtZWRpYVF1ZXJ5Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnKTtcblxuICAgIG1lZGlhUXVlcnkuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG1lZGlhUXVlcnkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICByZXR1cm4gY29sb3JTY2hlbWU7XG59XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlSXNDbGllbnQoKSB7XG4gIGNvbnN0IFtpc0NsaWVudCwgc2V0Q2xpZW50XSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldENsaWVudCh0cnVlKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiBpc0NsaWVudDtcbn1cbiIsImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IHF1ZXJ5ID0gJyhwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVByZWZlcnNSZWR1Y2VkTW90aW9uKCkge1xuICBjb25zdCBbcHJlZmVyc1JlZHVjZWRNb3Rpb24sIHNldFByZWZlcnNSZWR1Y2VkTW90aW9uXSA9IHVzZVN0YXRlKHRydWUpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbWVkaWFRdWVyeSA9IHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5KTtcbiAgICBzZXRQcmVmZXJzUmVkdWNlZE1vdGlvbihtZWRpYVF1ZXJ5Lm1hdGNoZXMpO1xuXG4gICAgY29uc3Qgb25DaGFuZ2UgPSAoZXZlbnQ6IE1lZGlhUXVlcnlMaXN0RXZlbnQpID0+IHtcbiAgICAgIHNldFByZWZlcnNSZWR1Y2VkTW90aW9uKGV2ZW50Lm1hdGNoZXMpO1xuICAgIH07XG5cbiAgICBtZWRpYVF1ZXJ5LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtZWRpYVF1ZXJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHByZWZlcnNSZWR1Y2VkTW90aW9uO1xufVxuIiwiZnVuY3Rpb24gc3R5bGVJbmplY3QoY3NzLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICB2YXIgaW5zZXJ0QXQgPSByZWYuaW5zZXJ0QXQ7XG5cbiAgaWYgKCFjc3MgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm47IH1cblxuICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cbiAgaWYgKGluc2VydEF0ID09PSAndG9wJykge1xuICAgIGlmIChoZWFkLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBzdHlsZUluamVjdDtcbiIsImltcG9ydCB0eXBlIHsgRGF5IGFzIFdlZWtEYXkgfSBmcm9tICdkYXRlLWZucyc7XG5pbXBvcnQge1xuICBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMsXG4gIGVhY2hEYXlPZkludGVydmFsLFxuICBlbmRPZlllYXIsXG4gIGZvcm1hdElTTyxcbiAgZ2V0RGF5LFxuICBnZXRNb250aCxcbiAgbmV4dERheSxcbiAgcGFyc2VJU08sXG4gIHN0YXJ0T2ZZZWFyLFxuICBzdWJXZWVrcyxcbn0gZnJvbSAnZGF0ZS1mbnMnO1xuXG5pbXBvcnQgeyBERUZBVUxUX01PTlRIX0xBQkVMUywgTkFNRVNQQUNFIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IEFjdGl2aXR5LCBXZWVrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbnRlcmZhY2UgTW9udGhMYWJlbCB7XG4gIHdlZWtJbmRleDogbnVtYmVyO1xuICBsYWJlbDogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBCeVdlZWtzKFxuICBhY3Rpdml0aWVzOiBBcnJheTxBY3Rpdml0eT4sXG4gIHdlZWtTdGFydDogV2Vla0RheSA9IDAsIC8vIDAgPSBTdW5kYXlcbik6IEFycmF5PFdlZWs+IHtcbiAgaWYgKGFjdGl2aXRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3Qgbm9ybWFsaXplZEFjdGl2aXRpZXMgPSBmaWxsSG9sZXMoYWN0aXZpdGllcyk7XG5cbiAgLy8gRGV0ZXJtaW5lIHRoZSBmaXJzdCBkYXRlIG9mIHRoZSBjYWxlbmRhci4gSWYgdGhlIGZpcnN0IGRhdGUgaXMgbm90IHRoZVxuICAvLyBzZXQgc3RhcnQgd2Vla2RheSwgdGhlIHNlbGVjdGVkIHdlZWtkYXkgb25lIHdlZWsgZWFybGllciBpcyB1c2VkLlxuICBjb25zdCBmaXJzdERhdGUgPSBwYXJzZUlTTyhub3JtYWxpemVkQWN0aXZpdGllc1swXS5kYXRlKTtcbiAgY29uc3QgZmlyc3RDYWxlbmRhckRhdGUgPVxuICAgIGdldERheShmaXJzdERhdGUpID09PSB3ZWVrU3RhcnQgPyBmaXJzdERhdGUgOiBzdWJXZWVrcyhuZXh0RGF5KGZpcnN0RGF0ZSwgd2Vla1N0YXJ0KSwgMSk7XG5cbiAgLy8gVG8gY29ycmVjdGx5IGdyb3VwIGFjdGl2aXRpZXMgYnkgd2VlaywgaXQgaXMgbmVjZXNzYXJ5IHRvIGxlZnQtcGFkIHRoZSBsaXN0XG4gIC8vIGJlY2F1c2UgdGhlIGZpcnN0IGRhdGUgbWlnaHQgbm90IGJlIHNldCBzdGFydCB3ZWVrZGF5LlxuICBjb25zdCBwYWRkZWRBY3Rpdml0aWVzID0gW1xuICAgIC4uLkFycmF5KGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhmaXJzdERhdGUsIGZpcnN0Q2FsZW5kYXJEYXRlKSkuZmlsbCh1bmRlZmluZWQpLFxuICAgIC4uLm5vcm1hbGl6ZWRBY3Rpdml0aWVzLFxuICBdO1xuXG4gIGNvbnN0IG51bWJlck9mV2Vla3MgPSBNYXRoLmNlaWwocGFkZGVkQWN0aXZpdGllcy5sZW5ndGggLyA3KTtcblxuICAvLyBGaW5hbGx5LCBncm91cCBhY3Rpdml0aWVzIGJ5IHdlZWtcbiAgcmV0dXJuIEFycmF5KG51bWJlck9mV2Vla3MpXG4gICAgLmZpbGwodW5kZWZpbmVkKVxuICAgIC5tYXAoKF8sIHdlZWtJbmRleCkgPT4gcGFkZGVkQWN0aXZpdGllcy5zbGljZSh3ZWVrSW5kZXggKiA3LCB3ZWVrSW5kZXggKiA3ICsgNykpO1xufVxuXG4vKipcbiAqIFRoZSBjYWxlbmRhciBleHBlY3RzIGEgY29udGludW91cyBzZXF1ZW5jZSBvZiBkYXlzLFxuICogc28gZmlsbCBnYXBzIHdpdGggZW1wdHkgYWN0aXZpdHkgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZmlsbEhvbGVzKGFjdGl2aXRpZXM6IEFycmF5PEFjdGl2aXR5Pik6IEFycmF5PEFjdGl2aXR5PiB7XG4gIGNvbnN0IGRhdGVNYXA6IFJlY29yZDxzdHJpbmcsIEFjdGl2aXR5PiA9IHt9O1xuICBmb3IgKGNvbnN0IGFjdGl2aXR5IG9mIGFjdGl2aXRpZXMpIHtcbiAgICBkYXRlTWFwW2FjdGl2aXR5LmRhdGVdID0gYWN0aXZpdHk7XG4gIH1cblxuICByZXR1cm4gZWFjaERheU9mSW50ZXJ2YWwoe1xuICAgIHN0YXJ0OiBwYXJzZUlTTyhhY3Rpdml0aWVzWzBdLmRhdGUpLFxuICAgIGVuZDogcGFyc2VJU08oYWN0aXZpdGllc1thY3Rpdml0aWVzLmxlbmd0aCAtIDFdLmRhdGUpLFxuICB9KS5tYXAoZGF5ID0+IHtcbiAgICBjb25zdCBkYXRlID0gZm9ybWF0SVNPKGRheSwgeyByZXByZXNlbnRhdGlvbjogJ2RhdGUnIH0pO1xuXG4gICAgaWYgKGRhdGVNYXBbZGF0ZV0pIHtcbiAgICAgIHJldHVybiBkYXRlTWFwW2RhdGVdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkYXRlLFxuICAgICAgY291bnQ6IDAsXG4gICAgICBsZXZlbDogMCxcbiAgICB9O1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vbnRoTGFiZWxzKFxuICB3ZWVrczogQXJyYXk8V2Vlaz4sXG4gIG1vbnRoTmFtZXM6IEFycmF5PHN0cmluZz4gPSBERUZBVUxUX01PTlRIX0xBQkVMUyxcbik6IEFycmF5PE1vbnRoTGFiZWw+IHtcbiAgcmV0dXJuIHdlZWtzXG4gICAgLnJlZHVjZTxBcnJheTxNb250aExhYmVsPj4oKGxhYmVscywgd2Vlaywgd2Vla0luZGV4KSA9PiB7XG4gICAgICBjb25zdCBmaXJzdEFjdGl2aXR5ID0gd2Vlay5maW5kKGFjdGl2aXR5ID0+IGFjdGl2aXR5ICE9PSB1bmRlZmluZWQpO1xuXG4gICAgICBpZiAoIWZpcnN0QWN0aXZpdHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGVycm9yOiBXZWVrICR7d2Vla0luZGV4ICsgMX0gaXMgZW1wdHk6IFske3dlZWt9XS5gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbW9udGggPSBtb250aE5hbWVzW2dldE1vbnRoKHBhcnNlSVNPKGZpcnN0QWN0aXZpdHkuZGF0ZSkpXTtcbiAgICAgIGNvbnN0IHByZXZMYWJlbCA9IGxhYmVsc1tsYWJlbHMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmICh3ZWVrSW5kZXggPT09IDAgfHwgcHJldkxhYmVsLmxhYmVsICE9PSBtb250aCkge1xuICAgICAgICByZXR1cm4gWy4uLmxhYmVscywgeyB3ZWVrSW5kZXgsIGxhYmVsOiBtb250aCB9XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9LCBbXSlcbiAgICAuZmlsdGVyKCh7IHdlZWtJbmRleCB9LCBpbmRleCwgbGFiZWxzKSA9PiB7XG4gICAgICAvLyBMYWJlbHMgc2hvdWxkIG9ubHkgYmUgc2hvd24gaWYgdGhlcmUgaXMgXCJlbm91Z2hcIiBzcGFjZSAoZGF0YSkuXG4gICAgICAvLyBUaGlzIGlzIGEgbmFpdmUgaW1wbGVtZW50YXRpb24gdGhhdCBkb2VzIG5vdCB0YWtlIHRoZSBibG9jayBzaXplLFxuICAgICAgLy8gZm9udCBzaXplIGV0Yy4gaW50byBhY2NvdW50LlxuICAgICAgY29uc3QgbWluV2Vla3MgPSAzO1xuXG4gICAgICAvLyBTa2lwIHRoZSBmaXJzdCBtb250aCBsYWJlbCBpZiB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIHRvIHRoZSBuZXh0IG9uZS5cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbGFiZWxzWzFdICYmIGxhYmVsc1sxXS53ZWVrSW5kZXggLSB3ZWVrSW5kZXggPj0gbWluV2Vla3M7XG4gICAgICB9XG5cbiAgICAgIC8vIFNraXAgdGhlIGxhc3QgbW9udGggbGFiZWwgdGhlIHRoZXJlIGlzIG5vdCBlbm91Z2ggZGF0YSBpbiB0aGF0IG1vbnRoIHRvXG4gICAgICAvLyBhdm9pZCBvdmVyZmxvd2luZyB0aGUgY2FsZW5kYXIgb24gdGhlIHJpZ2h0LlxuICAgICAgaWYgKGluZGV4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gd2Vla3Muc2xpY2Uod2Vla0luZGV4KS5sZW5ndGggPj0gbWluV2Vla3M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKG5hbWU6IHN0cmluZywgc3R5bGVzPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHN0eWxlcykge1xuICAgIHJldHVybiBgJHtOQU1FU1BBQ0V9X18ke25hbWV9ICR7c3R5bGVzfWA7XG4gIH1cblxuICByZXR1cm4gYCR7TkFNRVNQQUNFfV9fJHtuYW1lfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUVtcHR5RGF0YSgpOiBBcnJheTxBY3Rpdml0eT4ge1xuICBjb25zdCB5ZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuICBjb25zdCBkYXlzID0gZWFjaERheU9mSW50ZXJ2YWwoe1xuICAgIHN0YXJ0OiBuZXcgRGF0ZSh5ZWFyLCAwLCAxKSxcbiAgICBlbmQ6IG5ldyBEYXRlKHllYXIsIDExLCAzMSksXG4gIH0pO1xuXG4gIHJldHVybiBkYXlzLm1hcChkYXRlID0+ICh7XG4gICAgZGF0ZTogZm9ybWF0SVNPKGRhdGUsIHsgcmVwcmVzZW50YXRpb246ICdkYXRlJyB9KSxcbiAgICBjb3VudDogMCxcbiAgICBsZXZlbDogMCxcbiAgfSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVUZXN0RGF0YShhcmdzOiB7XG4gIGludGVydmFsPzogeyBzdGFydDogRGF0ZTsgZW5kOiBEYXRlIH07XG4gIG1heExldmVsPzogbnVtYmVyO1xufSk6IEFycmF5PEFjdGl2aXR5PiB7XG4gIGNvbnN0IG1heENvdW50ID0gMjA7XG4gIGNvbnN0IG1heExldmVsID0gYXJncy5tYXhMZXZlbCA/IE1hdGgubWF4KDEsIGFyZ3MubWF4TGV2ZWwpIDogNDtcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcblxuICBjb25zdCBkYXlzID0gZWFjaERheU9mSW50ZXJ2YWwoXG4gICAgYXJncy5pbnRlcnZhbCA/PyB7XG4gICAgICBzdGFydDogc3RhcnRPZlllYXIobm93KSxcbiAgICAgIGVuZDogZW5kT2ZZZWFyKG5vdyksXG4gICAgfSxcbiAgKTtcblxuICByZXR1cm4gZGF5cy5tYXAoZGF0ZSA9PiB7XG4gICAgLy8gVGhlIHJhbmRvbSBhY3Rpdml0eSBjb3VudCBpcyBzaGlmdGVkIGJ5IHVwIHRvIDgwJSB0b3dhcmRzIHplcm8uXG4gICAgY29uc3QgYyA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIG1heENvdW50IC0gTWF0aC5yYW5kb20oKSAqICgwLjggKiBtYXhDb3VudCkpO1xuICAgIGNvbnN0IGNvdW50ID0gTWF0aC5tYXgoMCwgYyk7XG4gICAgY29uc3QgbGV2ZWwgPSBNYXRoLmNlaWwoKGNvdW50IC8gbWF4Q291bnQpICogbWF4TGV2ZWwpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGU6IGZvcm1hdElTTyhkYXRlLCB7IHJlcHJlc2VudGF0aW9uOiAnZGF0ZScgfSksXG4gICAgICBjb3VudCxcbiAgICAgIGxldmVsLFxuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF4V2Vla2RheUxhYmVsTGVuZ3RoKFxuICBmaXJzdFdlZWs6IFdlZWssXG4gIHdlZWtTdGFydDogbnVtYmVyLFxuICBsYWJlbHM6IHN0cmluZ1tdLFxuICBmb250U2l6ZTogbnVtYmVyLFxuKTogbnVtYmVyIHtcbiAgcmV0dXJuIGZpcnN0V2Vlay5yZWR1Y2UoKG1heExlbmd0aCwgXywgaW5kZXgpID0+IHtcbiAgICBpZiAoaW5kZXggJSAyICE9PSAwKSB7XG4gICAgICBjb25zdCBkYXlJbmRleCA9IChpbmRleCArIHdlZWtTdGFydCkgJSA3O1xuICAgICAgY29uc3QgY3VyTGVuZ3RoID0gTWF0aC5jZWlsKGNhbGNUZXh0RGltZW5zaW9ucyhsYWJlbHNbZGF5SW5kZXhdLCBmb250U2l6ZSkud2lkdGgpO1xuXG4gICAgICByZXR1cm4gTWF0aC5tYXgobWF4TGVuZ3RoLCBjdXJMZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXhMZW5ndGg7XG4gIH0sIDApO1xufVxuXG5mdW5jdGlvbiBjYWxjVGV4dERpbWVuc2lvbnModGV4dDogc3RyaW5nLCBmb250U2l6ZTogbnVtYmVyKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxjVGV4dERpbWVuc2lvbnMoKSByZXF1aXJlcyBicm93c2VyIEFQSXMnKTtcbiAgfVxuXG4gIGlmIChmb250U2l6ZSA8IDEpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZm9udFNpemUgbXVzdCBiZSBwb3NpdGl2ZScpO1xuICB9XG5cbiAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHsgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICB9XG5cbiAgY29uc3QgbmFtZXNwYWNlID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgY29uc3Qgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgJ3N2ZycpO1xuXG4gIHN2Zy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIHN2Zy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIHN2Zy5zdHlsZS5mb250RmFtaWx5ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkuZm9udEZhbWlseTtcbiAgc3ZnLnN0eWxlLmZvbnRTaXplID0gYCR7Zm9udFNpemV9cHhgO1xuXG4gIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgJ3RleHQnKTtcbiAgdGV4dE5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuXG4gIHN2Zy5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgY29uc3QgYm91bmRpbmdCb3ggPSB0ZXh0Tm9kZS5nZXRCQm94KCk7XG5cbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzdmcpO1xuXG4gIHJldHVybiB7IHdpZHRoOiBib3VuZGluZ0JveC53aWR0aCwgaGVpZ2h0OiBib3VuZGluZ0JveC5oZWlnaHQgfTtcbn1cbiIsImltcG9ydCBjaHJvbWEgZnJvbSAnY2hyb21hLWpzJztcblxuaW1wb3J0IHsgQ29sb3IsIENvbG9yU2NhbGUsIFRoZW1lLCBUaGVtZUlucHV0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGhlbWUoaW5wdXQ/OiBUaGVtZUlucHV0LCBzaXplOiBudW1iZXIgPSA1KTogVGhlbWUge1xuICBjb25zdCBkZWZhdWx0VGhlbWUgPSBjcmVhdGVEZWZhdWx0VGhlbWUoc2l6ZSk7XG5cbiAgaWYgKGlucHV0KSB7XG4gICAgdmFsaWRhdGVUaGVtZShpbnB1dCwgc2l6ZSk7XG5cbiAgICBpbnB1dC5saWdodCA9IGlucHV0LmxpZ2h0ID8/IGRlZmF1bHRUaGVtZS5saWdodDtcbiAgICBpbnB1dC5kYXJrID0gaW5wdXQuZGFyayA/PyBkZWZhdWx0VGhlbWUuZGFyaztcblxuICAgIHJldHVybiB7XG4gICAgICBsaWdodDogaXNDb2xvclNjYWxlKGlucHV0LmxpZ2h0LCBzaXplKSA/IGlucHV0LmxpZ2h0IDogY3JlYXRlQ29sb3JTY2FsZShpbnB1dC5saWdodCwgc2l6ZSksXG4gICAgICBkYXJrOiBpc0NvbG9yU2NhbGUoaW5wdXQuZGFyaywgc2l6ZSkgPyBpbnB1dC5kYXJrIDogY3JlYXRlQ29sb3JTY2FsZShpbnB1dC5kYXJrLCBzaXplKSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRUaGVtZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFRoZW1lKHNpemU6IG51bWJlcik6IFRoZW1lIHtcbiAgcmV0dXJuIHtcbiAgICBsaWdodDogY3JlYXRlQ29sb3JTY2FsZShbJ2hzbCgwLCAwJSwgOTIlKScsICdoc2woMCwgMCUsIDI2JSknXSwgc2l6ZSksXG4gICAgZGFyazogY3JlYXRlQ29sb3JTY2FsZShbJ2hzbCgwLCAwJSwgMjAlKScsICdoc2woMCwgMCUsIDkyJSknXSwgc2l6ZSksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGhlbWUoaW5wdXQ6IFRoZW1lSW5wdXQsIHNpemU6IG51bWJlcikge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnb2JqZWN0JyB8fCAoaW5wdXQubGlnaHQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dC5kYXJrID09PSB1bmRlZmluZWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSB0aGVtZSBvYmplY3QgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBvZiB0aGUgZmllbGRzIFwibGlnaHRcIiBhbmQgXCJkYXJrXCIgd2l0aCBleGFjdGx5IDIgb3IgJHtzaXplfSBjb2xvcnMgcmVzcGVjdGl2ZWx5LmAsXG4gICAgKTtcbiAgfVxuXG4gIGlmIChpbnB1dC5saWdodCkge1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBpbnB1dC5saWdodDtcbiAgICBpZiAobGVuZ3RoICE9PSAyICYmIGxlbmd0aCAhPT0gc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgdGhlbWUubGlnaHQgbXVzdCBjb250YWluIGV4YWN0bHkgMiBvciAke3NpemV9IGNvbG9ycywgJHtsZW5ndGggYXMgbnVtYmVyfSBwYXNzZWQuYCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlucHV0LmRhcmspIHtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gaW5wdXQuZGFyaztcbiAgICBpZiAobGVuZ3RoICE9PSAyICYmIGxlbmd0aCAhPT0gc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgdGhlbWUuZGFyayBtdXN0IGNvbnRhaW4gZXhhY3RseSAyIG9yICR7c2l6ZX0gY29sb3JzLCAke2xlbmd0aCBhcyBudW1iZXJ9IHBhc3NlZC5gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb2xvclNjYWxlKGNvbG9yczogQXJyYXk8dW5rbm93bj4sIHNpemU6IG51bWJlcik6IGNvbG9ycyBpcyBDb2xvclNjYWxlIHtcbiAgY29uc3QgaW52YWxpZENvbG9yID0gY29sb3JzLmZpbmQoY29sb3IgPT4gIWNocm9tYS52YWxpZChjb2xvcikpO1xuXG4gIGlmIChpbnZhbGlkQ29sb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29sb3IgXCIke2ludmFsaWRDb2xvcn1cIiBwYXNzZWQuIEFsbCBDU1MgY29sb3IgZm9ybWF0cyBhcmUgYWNjZXB0ZWQuYCk7XG4gIH1cblxuICByZXR1cm4gY29sb3JzLmxlbmd0aCA9PT0gc2l6ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29sb3JTY2FsZShjb2xvcnM6IFtmcm9tOiBDb2xvciwgdG86IENvbG9yXSwgc2l6ZTogbnVtYmVyKTogQ29sb3JTY2FsZSB7XG4gIHJldHVybiBjaHJvbWEuc2NhbGUoY29sb3JzKS5tb2RlKCdsY2gnKS5jb2xvcnMoc2l6ZSk7XG59XG4iLCIndXNlIGNsaWVudCc7XG5cbmltcG9ydCBjaHJvbWEgZnJvbSAnY2hyb21hLWpzJztcbmltcG9ydCB0eXBlIHsgRGF5IGFzIFdlZWtEYXkgfSBmcm9tICdkYXRlLWZucyc7XG5pbXBvcnQgeyBnZXRZZWFyLCBwYXJzZUlTTyB9IGZyb20gJ2RhdGUtZm5zJztcbmltcG9ydCBSZWFjdCwgeyBDU1NQcm9wZXJ0aWVzLCBGcmFnbWVudCwgRnVuY3Rpb25Db21wb25lbnQsIFJlYWN0RWxlbWVudCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgREVGQVVMVF9MQUJFTFMsIExBQkVMX01BUkdJTiwgTkFNRVNQQUNFIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IHVzZUNvbG9yU2NoZW1lIH0gZnJvbSAnLi4vaG9va3MvdXNlQ29sb3JTY2hlbWUnO1xuaW1wb3J0IHsgdXNlSXNDbGllbnQgfSBmcm9tICcuLi9ob29rcy91c2VJc0NsaWVudCc7XG5pbXBvcnQgeyB1c2VQcmVmZXJzUmVkdWNlZE1vdGlvbiB9IGZyb20gJy4uL2hvb2tzL3VzZVByZWZlcnNSZWR1Y2VkTW90aW9uJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi4vc3R5bGVzL3N0eWxlcy5tb2R1bGUuY3NzJztcbmltcG9ydCB7XG4gIEFjdGl2aXR5LFxuICBCbG9ja0VsZW1lbnQsXG4gIEV2ZW50SGFuZGxlck1hcCxcbiAgTGFiZWxzLFxuICBSZWFjdEV2ZW50LFxuICBTVkdSZWN0RXZlbnRIYW5kbGVyLFxuICBUaGVtZUlucHV0LFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1xuICBnZW5lcmF0ZUVtcHR5RGF0YSxcbiAgZ2V0Q2xhc3NOYW1lLFxuICBnZXRNb250aExhYmVscyxcbiAgZ3JvdXBCeVdlZWtzLFxuICBtYXhXZWVrZGF5TGFiZWxMZW5ndGgsXG59IGZyb20gJy4uL3V0aWxzL2NhbGVuZGFyJztcbmltcG9ydCB7IGNyZWF0ZVRoZW1lIH0gZnJvbSAnLi4vdXRpbHMvdGhlbWUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb3BzIHtcbiAgLyoqXG4gICAqIExpc3Qgb2YgY2FsZW5kYXIgZW50cmllcy4gRXZlcnkgYEFjdGl2aXR5YCBvYmplY3QgcmVxdWlyZXMgYW4gSVNPIDg2MDFcbiAgICogYGRhdGVgIHN0cmluZyBpbiB0aGUgZm9ybWF0IGB5eXl5LU1NLWRkYCwgYSBgY291bnRgIHByb3BlcnR5IHdpdGggdGhlXG4gICAqIGFtb3VudCBvZiB0cmFja2VkIGRhdGEgYW5kIGEgYGxldmVsYCBwcm9wZXJ0eSBpbiB0aGUgcmFuZ2UgYDAtbWF4TGV2ZWxgXG4gICAqIHRvIHNwZWNpZnkgYWN0aXZpdHkgaW50ZW5zaXR5LiBUaGUgYG1heExldmVsYCBwcm9wIGlzIDQgYnkgZGVmYXVsdC5cbiAgICpcbiAgICogRm9yIG1pc3NpbmcgZGF0ZXMsIG5vIGFjdGl2aXR5IGlzIGFzc3VtZWQuIFRoaXMgYWxsb3dzIGNob29zaW5nIHRoZSBzdGFydFxuICAgKiBhbmQgZW5kIGRhdGUgb2YgdGhlIGNhbGVuZGFyIGFyYml0cmFyaWx5IGJ5IHBhc3NpbmcgZW1wdHkgZW50cmllcyBhcyB0aGVcbiAgICogZmlyc3QgYW5kIGxhc3QgaXRlbS5cbiAgICpcbiAgICogRXhhbXBsZSBvYmplY3Q6XG4gICAqXG4gICAqIGBgYGpzb25cbiAgICoge1xuICAgKiAgIGRhdGU6IFwiMjAyMS0wMi0yMFwiLFxuICAgKiAgIGNvdW50OiAxNixcbiAgICogICBsZXZlbDogM1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgZGF0YTogQXJyYXk8QWN0aXZpdHk+O1xuICAvKipcbiAgICogTWFyZ2luIGJldHdlZW4gYmxvY2tzIGluIHBpeGVscy5cbiAgICovXG4gIGJsb2NrTWFyZ2luPzogbnVtYmVyO1xuICAvKipcbiAgICogQm9yZGVyIHJhZGl1cyBvZiBibG9ja3MgaW4gcGl4ZWxzLlxuICAgKi9cbiAgYmxvY2tSYWRpdXM/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBCbG9jayBzaXplIGluIHBpeGVscy5cbiAgICovXG4gIGJsb2NrU2l6ZT86IG51bWJlcjtcbiAgLyoqXG4gICAqIFVzZSBhIHNwZWNpZmljIGNvbG9yIHNjaGVtZSBpbnN0ZWFkIG9mIHRoZSBzeXN0ZW0gb25lLiBTdXBwb3J0ZWQgdmFsdWVzXG4gICAqIGFyZSBgJ2xpZ2h0J2AgYW5kIGAnZGFyaydgLlxuICAgKi9cbiAgY29sb3JTY2hlbWU/OiAnbGlnaHQnIHwgJ2RhcmsnO1xuICAvKipcbiAgICogRXZlbnQgaGFuZGxlcnMgdG8gcmVnaXN0ZXIgZm9yIHRoZSBTVkcgYDxyZWN0PmAgZWxlbWVudHMgdGhhdCBhcmUgdXNlZCB0b1xuICAgKiByZW5kZXIgdGhlIGNhbGVuZGFyIGRheXMuIEhhbmRsZXIgc2lnbmF0dXJlOiBgZXZlbnQgPT4gYWN0aXZpdHkgPT4gdm9pZGBcbiAgICovXG4gIGV2ZW50SGFuZGxlcnM/OiBFdmVudEhhbmRsZXJNYXA7XG4gIC8qKlxuICAgKiBGb250IHNpemUgZm9yIHRleHQgaW4gcGl4ZWxzLlxuICAgKi9cbiAgZm9udFNpemU/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBUb2dnbGUgdG8gaGlkZSBjb2xvciBsZWdlbmQgYmVsb3cgY2FsZW5kYXIuXG4gICAqL1xuICBoaWRlQ29sb3JMZWdlbmQ/OiBib29sZWFuO1xuICAvKipcbiAgICogVG9nZ2xlIHRvIGhpZGUgbW9udGggbGFiZWxzIGFib3ZlIGNhbGVuZGFyLlxuICAgKi9cbiAgaGlkZU1vbnRoTGFiZWxzPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFRvZ2dsZSB0byBoaWRlIHRoZSB0b3RhbCBjb3VudCBiZWxvdyBjYWxlbmRhci5cbiAgICovXG4gIGhpZGVUb3RhbENvdW50PzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIExvY2FsaXphdGlvbiBzdHJpbmdzIGZvciBhbGwgY2FsZW5kYXIgbGFiZWxzLlxuICAgKlxuICAgKiBgdG90YWxDb3VudGAgc3VwcG9ydHMgdGhlIHBsYWNlaG9sZGVycyBge3tjb3VudH19YCBhbmQgYHt7eWVhcn19YC5cbiAgICovXG4gIGxhYmVscz86IExhYmVscztcbiAgLyoqXG4gICAqIE1heGltdW0gYWN0aXZpdHkgbGV2ZWwgKHplcm8gaW5kZXhlZCkuXG4gICAqL1xuICBtYXhMZXZlbD86IG51bWJlcjtcbiAgLyoqXG4gICAqIFRvZ2dsZSBmb3IgbG9hZGluZyBzdGF0ZS4gYGRhdGFgIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZCBpZiBzZXQuXG4gICAqL1xuICBsb2FkaW5nPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFJlbmRlciBwcm9wIGZvciBjYWxlbmRhciBibG9ja3MgKGFjdGl2aXRpZXMpLiBGb3IgZXhhbXBsZSwgdXNlZnVsIHRvIHdyYXBcbiAgICogdGhlIGVsZW1lbnQgd2l0aCBhIHRvb2x0aXAgY29tcG9uZW50LiBVc2UgYFJlYWN0LmNsb25lRWxlbWVudGAgdG8gcGFzc1xuICAgKiBhZGRpdGlvbmFsIHByb3BzIHRvIHRoZSBlbGVtZW50IGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIHJlbmRlckJsb2NrPzogKGJsb2NrOiBCbG9ja0VsZW1lbnQsIGFjdGl2aXR5OiBBY3Rpdml0eSkgPT4gUmVhY3RFbGVtZW50O1xuICAvKipcbiAgICogVG9nZ2xlIHRvIHNob3cgd2Vla2RheSBsYWJlbHMgbGVmdCB0byB0aGUgY2FsZW5kYXIuXG4gICAqL1xuICBzaG93V2Vla2RheUxhYmVscz86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBTdHlsZSBvYmplY3QgdG8gcGFzcyB0byBjb21wb25lbnQgY29udGFpbmVyLlxuICAgKi9cbiAgc3R5bGU/OiBDU1NQcm9wZXJ0aWVzO1xuICAvKipcbiAgICogU2V0IHRoZSBjYWxlbmRhciBjb2xvcnMgZm9yIHRoZSBsaWdodCBhbmQgZGFyayBzeXN0ZW0gY29sb3Igc2NoZW1lLlxuICAgKiBEZWZpbmUgZWFjaCBjb2xvciBzY2FsZSBleHBsaWNpdGx5IGJ5IHNldHRpbmdzIGFsbCBjb2xvcnMgKDUgcGVyIGRlZmF1bHQpXG4gICAqIG9yIHBhc3MgZXhhY3RseSB0d28gY29sb3JzICh0aGUgbG93ZXN0IGFuZCBoaWdoZXN0IGludGVuc2l0eSkgdG8gY2FsY3VsYXRlXG4gICAqIGEgc2luZ2xlLWh1ZSBzY2FsZS4gQ29sb3JzIGNhbiBiZSBzcGVjaWZpZWQgaW4gYW55IHZhbGlkIENTUyBmb3JtYXQuXG4gICAqXG4gICAqIFRoZSBjb2xvcnMgZm9yIGF0IGxlYXN0IG9uZSBzY2hlbWUgbXVzdCBiZSBzZXQuIElmIHVuZGVmaW5lZCwgdGhlIGRlZmF1bHRcbiAgICogdGhlbWUgaXMgdXNlZC4gQnkgZGVmYXVsdCwgdGhlIGNhbGVuZGFyIHdpbGwgc2VsZWN0IHRoZSBjdXJyZW50IHN5c3RlbSBjb2xvclxuICAgKiBzY2hlbWUsIGJ1dCB5b3UgY2FuIGVuZm9yY2UgYSBzcGVjaWZpYyBzY2hlbWUgd2l0aCB0aGUgYGNvbG9yU2NoZW1lYCBwcm9wLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGB0c3hcbiAgICogPEFjdGl2aXR5Q2FsZW5kYXJcbiAgICogICBkYXRhPXtkYXRhfVxuICAgKiAgIHRoZW1lPXt7XG4gICAqICAgICBsaWdodDogWydoc2woMCwgMCUsIDkyJSknLCAnZmlyZWJyaWNrJ10sXG4gICAqICAgICBkYXJrOiBbJyMzMzMnLCAncmdiKDIxNCwgMTYsIDE3NCknXSxcbiAgICogICB9fVxuICAgKiAvPlxuICAgKiBgYGBcbiAgICpcbiAgICovXG4gIHRoZW1lPzogVGhlbWVJbnB1dDtcbiAgLyoqXG4gICAqIE92ZXJ3cml0ZSB0aGUgdG90YWwgYWN0aXZpdHkgY291bnQuXG4gICAqL1xuICB0b3RhbENvdW50PzogbnVtYmVyO1xuICAvKipcbiAgICogSW5kZXggb2YgZGF5IHRvIGJlIHVzZWQgYXMgc3RhcnQgb2Ygd2Vlay4gMCByZXByZXNlbnRzIFN1bmRheS5cbiAgICovXG4gIHdlZWtTdGFydD86IFdlZWtEYXk7XG59XG5cbmNvbnN0IEFjdGl2aXR5Q2FsZW5kYXI6IEZ1bmN0aW9uQ29tcG9uZW50PFByb3BzPiA9ICh7XG4gIGRhdGEsXG4gIGJsb2NrTWFyZ2luID0gNCxcbiAgYmxvY2tSYWRpdXMgPSAyLFxuICBibG9ja1NpemUgPSAxMixcbiAgY29sb3JTY2hlbWUgPSB1bmRlZmluZWQsXG4gIGV2ZW50SGFuZGxlcnMgPSB7fSxcbiAgZm9udFNpemUgPSAxNCxcbiAgaGlkZUNvbG9yTGVnZW5kID0gZmFsc2UsXG4gIGhpZGVNb250aExhYmVscyA9IGZhbHNlLFxuICBoaWRlVG90YWxDb3VudCA9IGZhbHNlLFxuICBsYWJlbHM6IGxhYmVsc1Byb3AgPSB1bmRlZmluZWQsXG4gIG1heExldmVsID0gNCxcbiAgbG9hZGluZyA9IGZhbHNlLFxuICByZW5kZXJCbG9jayA9IHVuZGVmaW5lZCxcbiAgc2hvd1dlZWtkYXlMYWJlbHMgPSBmYWxzZSxcbiAgc3R5bGU6IHN0eWxlUHJvcCA9IHt9LFxuICB0aGVtZTogdGhlbWVQcm9wID0gdW5kZWZpbmVkLFxuICB0b3RhbENvdW50OiB0b3RhbENvdW50UHJvcCA9IHVuZGVmaW5lZCxcbiAgd2Vla1N0YXJ0ID0gMCwgLy8gU3VuZGF5XG59OiBQcm9wcykgPT4ge1xuICBtYXhMZXZlbCA9IE1hdGgubWF4KDEsIG1heExldmVsKTtcblxuICBjb25zdCB0aGVtZSA9IGNyZWF0ZVRoZW1lKHRoZW1lUHJvcCwgbWF4TGV2ZWwgKyAxKTtcbiAgY29uc3Qgc3lzdGVtQ29sb3JTY2hlbWUgPSB1c2VDb2xvclNjaGVtZSgpO1xuICBjb25zdCBjb2xvclNjYWxlID0gdGhlbWVbY29sb3JTY2hlbWUgPz8gc3lzdGVtQ29sb3JTY2hlbWVdO1xuXG4gIGNvbnN0IHVzZUFuaW1hdGlvbiA9ICF1c2VQcmVmZXJzUmVkdWNlZE1vdGlvbigpO1xuXG4gIC8vIENhbGN1bGF0aW5nIHRoZSB3ZWVrZGF5IGxhYmVsIG9mZnNldCBvbmx5IHdvcmtzIGluIHRoZSBicm93c2VyLlxuICAvLyBTbyBkaXNhYmxlIFNTUiBpbiB0aGlzIGNhc2UuXG4gIGNvbnN0IGlzQ2xpZW50ID0gdXNlSXNDbGllbnQoKTtcbiAgaWYgKHNob3dXZWVrZGF5TGFiZWxzICYmICFpc0NsaWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGxvYWRpbmcpIHtcbiAgICBkYXRhID0gZ2VuZXJhdGVFbXB0eURhdGEoKTtcbiAgfVxuXG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgeWVhciA9IGdldFllYXIocGFyc2VJU08oZGF0YVswXT8uZGF0ZSkpO1xuICBjb25zdCB3ZWVrcyA9IGdyb3VwQnlXZWVrcyhkYXRhLCB3ZWVrU3RhcnQpO1xuXG4gIGNvbnN0IGxhYmVscyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfTEFCRUxTLCBsYWJlbHNQcm9wKTtcbiAgY29uc3QgbGFiZWxIZWlnaHQgPSBoaWRlTW9udGhMYWJlbHMgPyAwIDogZm9udFNpemUgKyBMQUJFTF9NQVJHSU47XG5cbiAgY29uc3Qgd2Vla2RheUxhYmVsT2Zmc2V0ID0gc2hvd1dlZWtkYXlMYWJlbHNcbiAgICA/IG1heFdlZWtkYXlMYWJlbExlbmd0aCh3ZWVrc1swXSwgd2Vla1N0YXJ0LCBsYWJlbHMud2Vla2RheXMsIGZvbnRTaXplKSArIExBQkVMX01BUkdJTlxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3ZWVrcy5sZW5ndGggKiAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pIC0gYmxvY2tNYXJnaW4sXG4gICAgICBoZWlnaHQ6IGxhYmVsSGVpZ2h0ICsgKGJsb2NrU2l6ZSArIGJsb2NrTWFyZ2luKSAqIDcgLSBibG9ja01hcmdpbixcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RXZlbnRIYW5kbGVycyhhY3Rpdml0eTogQWN0aXZpdHkpOiBTVkdSZWN0RXZlbnRIYW5kbGVyIHtcbiAgICByZXR1cm4gKFxuICAgICAgT2JqZWN0LmtleXMoZXZlbnRIYW5kbGVycykgYXMgQXJyYXk8a2V5b2YgU1ZHUmVjdEV2ZW50SGFuZGxlcj5cbiAgICApLnJlZHVjZTxTVkdSZWN0RXZlbnRIYW5kbGVyPihcbiAgICAgIChoYW5kbGVycywga2V5KSA9PiAoe1xuICAgICAgICAuLi5oYW5kbGVycyxcbiAgICAgICAgW2tleV06IChldmVudDogUmVhY3RFdmVudDxTVkdSZWN0RWxlbWVudD4pID0+IGV2ZW50SGFuZGxlcnNba2V5XT8uKGV2ZW50KShhY3Rpdml0eSksXG4gICAgICB9KSxcbiAgICAgIHt9LFxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJDYWxlbmRhcigpIHtcbiAgICByZXR1cm4gd2Vla3NcbiAgICAgIC5tYXAoKHdlZWssIHdlZWtJbmRleCkgPT5cbiAgICAgICAgd2Vlay5tYXAoKGFjdGl2aXR5LCBkYXlJbmRleCkgPT4ge1xuICAgICAgICAgIGlmICghYWN0aXZpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhY3Rpdml0eS5sZXZlbCA8IDAgfHwgYWN0aXZpdHkubGV2ZWwgPiBtYXhMZXZlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICAgIGBQcm92aWRlZCBhY3Rpdml0eSBsZXZlbCAke2FjdGl2aXR5LmxldmVsfSBmb3IgJHthY3Rpdml0eS5kYXRlfSBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYmV0d2VlbiAwIGFuZCAke21heExldmVsfS5gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBzdHlsZSA9XG4gICAgICAgICAgICBsb2FkaW5nICYmIHVzZUFuaW1hdGlvblxuICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogYCR7c3R5bGVzLmxvYWRpbmdBbmltYXRpb259IDEuNzVzIGVhc2UtaW4tb3V0IGluZmluaXRlYCxcbiAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkRlbGF5OiBgJHt3ZWVrSW5kZXggKiAyMCArIGRheUluZGV4ICogMjB9bXNgLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBjb25zdCBibG9jayA9IChcbiAgICAgICAgICAgIDxyZWN0XG4gICAgICAgICAgICAgIHsuLi5nZXRFdmVudEhhbmRsZXJzKGFjdGl2aXR5KX1cbiAgICAgICAgICAgICAgeD17MH1cbiAgICAgICAgICAgICAgeT17bGFiZWxIZWlnaHQgKyAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogZGF5SW5kZXh9XG4gICAgICAgICAgICAgIHdpZHRoPXtibG9ja1NpemV9XG4gICAgICAgICAgICAgIGhlaWdodD17YmxvY2tTaXplfVxuICAgICAgICAgICAgICByeD17YmxvY2tSYWRpdXN9XG4gICAgICAgICAgICAgIHJ5PXtibG9ja1JhZGl1c31cbiAgICAgICAgICAgICAgZmlsbD17Y29sb3JTY2FsZVthY3Rpdml0eS5sZXZlbF19XG4gICAgICAgICAgICAgIGRhdGEtZGF0ZT17YWN0aXZpdHkuZGF0ZX1cbiAgICAgICAgICAgICAgZGF0YS1sZXZlbD17YWN0aXZpdHkubGV2ZWx9XG4gICAgICAgICAgICAgIHN0eWxlPXtzdHlsZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8RnJhZ21lbnQga2V5PXthY3Rpdml0eS5kYXRlfT5cbiAgICAgICAgICAgICAge3JlbmRlckJsb2NrID8gcmVuZGVyQmxvY2soYmxvY2ssIGFjdGl2aXR5KSA6IGJsb2NrfVxuICAgICAgICAgICAgPC9GcmFnbWVudD5cbiAgICAgICAgICApO1xuICAgICAgICB9KSxcbiAgICAgIClcbiAgICAgIC5tYXAoKHdlZWssIHgpID0+IChcbiAgICAgICAgPGcga2V5PXt4fSB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHsoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogeH0sIDApYH0+XG4gICAgICAgICAge3dlZWt9XG4gICAgICAgIDwvZz5cbiAgICAgICkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyRm9vdGVyKCkge1xuICAgIGlmIChoaWRlVG90YWxDb3VudCAmJiBoaWRlQ29sb3JMZWdlbmQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHRvdGFsQ291bnQgPVxuICAgICAgdHlwZW9mIHRvdGFsQ291bnRQcm9wID09PSAnbnVtYmVyJ1xuICAgICAgICA/IHRvdGFsQ291bnRQcm9wXG4gICAgICAgIDogZGF0YS5yZWR1Y2UoKHN1bSwgYWN0aXZpdHkpID0+IHN1bSArIGFjdGl2aXR5LmNvdW50LCAwKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8Zm9vdGVyXG4gICAgICAgIGNsYXNzTmFtZT17Z2V0Q2xhc3NOYW1lKCdmb290ZXInLCBzdHlsZXMuZm9vdGVyKX1cbiAgICAgICAgc3R5bGU9e3sgbWFyZ2luTGVmdDogd2Vla2RheUxhYmVsT2Zmc2V0IH19XG4gICAgICA+XG4gICAgICAgIHsvKiBQbGFjZWhvbGRlciAqL31cbiAgICAgICAge2xvYWRpbmcgJiYgPGRpdj4mbmJzcDs8L2Rpdj59XG5cbiAgICAgICAgeyFsb2FkaW5nICYmICFoaWRlVG90YWxDb3VudCAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2dldENsYXNzTmFtZSgnY291bnQnKX0+XG4gICAgICAgICAgICB7bGFiZWxzLnRvdGFsQ291bnRcbiAgICAgICAgICAgICAgPyBsYWJlbHMudG90YWxDb3VudFxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3t7Y291bnR9fScsIFN0cmluZyh0b3RhbENvdW50KSlcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCd7e3llYXJ9fScsIFN0cmluZyh5ZWFyKSlcbiAgICAgICAgICAgICAgOiBgJHt0b3RhbENvdW50fSBhY3Rpdml0aWVzIGluICR7eWVhcn1gfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuXG4gICAgICAgIHshbG9hZGluZyAmJiAhaGlkZUNvbG9yTGVnZW5kICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Z2V0Q2xhc3NOYW1lKCdsZWdlbmQtY29sb3JzJywgc3R5bGVzLmxlZ2VuZENvbG9ycyl9PlxuICAgICAgICAgICAgPHNwYW4gc3R5bGU9e3sgbWFyZ2luUmlnaHQ6ICcwLjRlbScgfX0+e2xhYmVscz8ubGVnZW5kPy5sZXNzID8/ICdMZXNzJ308L3NwYW4+XG4gICAgICAgICAgICB7QXJyYXkobWF4TGV2ZWwgKyAxKVxuICAgICAgICAgICAgICAuZmlsbCh1bmRlZmluZWQpXG4gICAgICAgICAgICAgIC5tYXAoKF8sIGxldmVsKSA9PiAoXG4gICAgICAgICAgICAgICAgPHN2ZyB3aWR0aD17YmxvY2tTaXplfSBoZWlnaHQ9e2Jsb2NrU2l6ZX0ga2V5PXtsZXZlbH0+XG4gICAgICAgICAgICAgICAgICA8cmVjdFxuICAgICAgICAgICAgICAgICAgICB3aWR0aD17YmxvY2tTaXplfVxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ9e2Jsb2NrU2l6ZX1cbiAgICAgICAgICAgICAgICAgICAgZmlsbD17Y29sb3JTY2FsZVtsZXZlbF19XG4gICAgICAgICAgICAgICAgICAgIHJ4PXtibG9ja1JhZGl1c31cbiAgICAgICAgICAgICAgICAgICAgcnk9e2Jsb2NrUmFkaXVzfVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBtYXJnaW5MZWZ0OiAnMC40ZW0nIH19PntsYWJlbHM/LmxlZ2VuZD8ubW9yZSA/PyAnTW9yZSd9PC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9mb290ZXI+XG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlckxhYmVscygpIHtcbiAgICBpZiAoIXNob3dXZWVrZGF5TGFiZWxzICYmIGhpZGVNb250aExhYmVscykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDw+XG4gICAgICAgIHtzaG93V2Vla2RheUxhYmVscyAmJiAoXG4gICAgICAgICAgPGcgY2xhc3NOYW1lPXtnZXRDbGFzc05hbWUoJ2xlZ2VuZC13ZWVrZGF5Jyl9PlxuICAgICAgICAgICAge3dlZWtzWzBdLm1hcCgoXywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgZGF5SW5kZXggPSAoaW5kZXggKyB3ZWVrU3RhcnQpICUgNztcblxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgICAgICB4PXstTEFCRUxfTUFSR0lOfVxuICAgICAgICAgICAgICAgICAgeT17bGFiZWxIZWlnaHQgKyAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogaW5kZXggKyBibG9ja1NpemUgLyAyfVxuICAgICAgICAgICAgICAgICAgZG9taW5hbnRCYXNlbGluZT1cIm1pZGRsZVwiXG4gICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yPVwiZW5kXCJcbiAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge2xhYmVscy53ZWVrZGF5c1tkYXlJbmRleF19XG4gICAgICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgPC9nPlxuICAgICAgICApfVxuICAgICAgICB7IWhpZGVNb250aExhYmVscyAmJiAoXG4gICAgICAgICAgPGcgY2xhc3NOYW1lPXtnZXRDbGFzc05hbWUoJ2xlZ2VuZC1tb250aCcpfT5cbiAgICAgICAgICAgIHtnZXRNb250aExhYmVscyh3ZWVrcywgbGFiZWxzLm1vbnRocykubWFwKCh7IGxhYmVsLCB3ZWVrSW5kZXggfSkgPT4gKFxuICAgICAgICAgICAgICA8dGV4dFxuICAgICAgICAgICAgICAgIHg9eyhibG9ja1NpemUgKyBibG9ja01hcmdpbikgKiB3ZWVrSW5kZXh9XG4gICAgICAgICAgICAgICAgZG9taW5hbnRCYXNlbGluZT1cImhhbmdpbmdcIlxuICAgICAgICAgICAgICAgIGtleT17d2Vla0luZGV4fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge2xhYmVsfVxuICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L2c+XG4gICAgICAgICl9XG4gICAgICA8Lz5cbiAgICApO1xuICB9XG5cbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBnZXREaW1lbnNpb25zKCk7XG5cbiAgY29uc3QgY29udGFpbmVyU3R5bGVzID0ge1xuICAgIGZvbnRTaXplLFxuICAgIC4uLih1c2VBbmltYXRpb24gJiYge1xuICAgICAgW2AtLSR7TkFNRVNQQUNFfS1sb2FkaW5nYF06IGNvbG9yU2NhbGVbMF0sXG4gICAgICBbYC0tJHtOQU1FU1BBQ0V9LWxvYWRpbmctYWN0aXZlYF06XG4gICAgICAgIGNvbG9yU2NoZW1lID09PSAnbGlnaHQnXG4gICAgICAgICAgPyBjaHJvbWEoY29sb3JTY2FsZVswXSkuZGFya2VuKDAuMykuaGV4KClcbiAgICAgICAgICA6IGNocm9tYShjb2xvclNjYWxlWzBdKS5icmlnaHRlbigwLjI1KS5oZXgoKSxcbiAgICB9KSxcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxhcnRpY2xlXG4gICAgICBjbGFzc05hbWU9e2Ake05BTUVTUEFDRX0gJHtzdHlsZXMuY29udGFpbmVyfWB9XG4gICAgICBzdHlsZT17eyAuLi5zdHlsZVByb3AsIC4uLmNvbnRhaW5lclN0eWxlcyB9fVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtnZXRDbGFzc05hbWUoJ3Njcm9sbC1jb250YWluZXInLCBzdHlsZXMuc2Nyb2xsQ29udGFpbmVyKX0+XG4gICAgICAgIDxzdmdcbiAgICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgICAgdmlld0JveD17YDAgMCAke3dpZHRofSAke2hlaWdodH1gfVxuICAgICAgICAgIGNsYXNzTmFtZT17Z2V0Q2xhc3NOYW1lKCdjYWxlbmRhcicsIHN0eWxlcy5jYWxlbmRhcil9XG4gICAgICAgICAgc3R5bGU9e3sgbWFyZ2luTGVmdDogd2Vla2RheUxhYmVsT2Zmc2V0IH19XG4gICAgICAgID5cbiAgICAgICAgICB7IWxvYWRpbmcgJiYgcmVuZGVyTGFiZWxzKCl9XG4gICAgICAgICAge3JlbmRlckNhbGVuZGFyKCl9XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9kaXY+XG4gICAgICB7cmVuZGVyRm9vdGVyKCl9XG4gICAgPC9hcnRpY2xlPlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IFNrZWxldG9uOiBGdW5jdGlvbkNvbXBvbmVudDxPbWl0PFByb3BzLCAnZGF0YSc+PiA9IHByb3BzID0+IChcbiAgPEFjdGl2aXR5Q2FsZW5kYXIgZGF0YT17W119IHsuLi5wcm9wc30gLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IEFjdGl2aXR5Q2FsZW5kYXI7XG4iXSwibmFtZXMiOlsiTkFNRVNQQUNFIiwiTEFCRUxfTUFSR0lOIiwiREVGQVVMVF9NT05USF9MQUJFTFMiLCJERUZBVUxUX0xBQkVMUyIsIm1vbnRocyIsIndlZWtkYXlzIiwidG90YWxDb3VudCIsImxlZ2VuZCIsImxlc3MiLCJtb3JlIiwidXNlQ29sb3JTY2hlbWUiLCJjb2xvclNjaGVtZSIsInNldENvbG9yU2NoZW1lIiwidXNlU3RhdGUiLCJvbkNoYW5nZSIsImV2ZW50IiwibWF0Y2hlcyIsInVzZUVmZmVjdCIsIm1lZGlhUXVlcnkiLCJ3aW5kb3ciLCJtYXRjaE1lZGlhIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1c2VJc0NsaWVudCIsImlzQ2xpZW50Iiwic2V0Q2xpZW50IiwicXVlcnkiLCJ1c2VQcmVmZXJzUmVkdWNlZE1vdGlvbiIsInByZWZlcnNSZWR1Y2VkTW90aW9uIiwic2V0UHJlZmVyc1JlZHVjZWRNb3Rpb24iLCJzdHlsZUluamVjdCIsImNzcyIsInJlZiIsImluc2VydEF0IiwiZG9jdW1lbnQiLCJoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzdHlsZSIsImNyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwiZmlyc3RDaGlsZCIsImluc2VydEJlZm9yZSIsImFwcGVuZENoaWxkIiwic3R5bGVTaGVldCIsImNzc1RleHQiLCJjcmVhdGVUZXh0Tm9kZSIsImdyb3VwQnlXZWVrcyIsImFjdGl2aXRpZXMiLCJ3ZWVrU3RhcnQiLCJsZW5ndGgiLCJub3JtYWxpemVkQWN0aXZpdGllcyIsImZpbGxIb2xlcyIsImZpcnN0RGF0ZSIsInBhcnNlSVNPIiwiZGF0ZSIsImZpcnN0Q2FsZW5kYXJEYXRlIiwiZ2V0RGF5Iiwic3ViV2Vla3MiLCJuZXh0RGF5IiwicGFkZGVkQWN0aXZpdGllcyIsIkFycmF5IiwiZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzIiwiZmlsbCIsInVuZGVmaW5lZCIsIm51bWJlck9mV2Vla3MiLCJNYXRoIiwiY2VpbCIsIm1hcCIsIl8iLCJ3ZWVrSW5kZXgiLCJzbGljZSIsImRhdGVNYXAiLCJhY3Rpdml0eSIsImVhY2hEYXlPZkludGVydmFsIiwic3RhcnQiLCJlbmQiLCJkYXkiLCJmb3JtYXRJU08iLCJyZXByZXNlbnRhdGlvbiIsImNvdW50IiwibGV2ZWwiLCJnZXRNb250aExhYmVscyIsIndlZWtzIiwibW9udGhOYW1lcyIsInJlZHVjZSIsImxhYmVscyIsIndlZWsiLCJmaXJzdEFjdGl2aXR5IiwiZmluZCIsIkVycm9yIiwibW9udGgiLCJnZXRNb250aCIsInByZXZMYWJlbCIsImxhYmVsIiwiZmlsdGVyIiwiaW5kZXgiLCJtaW5XZWVrcyIsImdldENsYXNzTmFtZSIsIm5hbWUiLCJzdHlsZXMiLCJnZW5lcmF0ZUVtcHR5RGF0YSIsInllYXIiLCJEYXRlIiwiZ2V0RnVsbFllYXIiLCJkYXlzIiwibWF4V2Vla2RheUxhYmVsTGVuZ3RoIiwiZmlyc3RXZWVrIiwiZm9udFNpemUiLCJtYXhMZW5ndGgiLCJkYXlJbmRleCIsImN1ckxlbmd0aCIsImNhbGNUZXh0RGltZW5zaW9ucyIsIndpZHRoIiwibWF4IiwidGV4dCIsIlJhbmdlRXJyb3IiLCJoZWlnaHQiLCJuYW1lc3BhY2UiLCJzdmciLCJjcmVhdGVFbGVtZW50TlMiLCJwb3NpdGlvbiIsInZpc2liaWxpdHkiLCJmb250RmFtaWx5IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImJvZHkiLCJ0ZXh0Tm9kZSIsInRleHRDb250ZW50IiwiYm91bmRpbmdCb3giLCJnZXRCQm94IiwicmVtb3ZlQ2hpbGQiLCJjcmVhdGVUaGVtZSIsImlucHV0Iiwic2l6ZSIsImRlZmF1bHRUaGVtZSIsImNyZWF0ZURlZmF1bHRUaGVtZSIsInZhbGlkYXRlVGhlbWUiLCJsaWdodCIsImRhcmsiLCJpc0NvbG9yU2NhbGUiLCJjcmVhdGVDb2xvclNjYWxlIiwiY29sb3JzIiwiaW52YWxpZENvbG9yIiwiY29sb3IiLCJjaHJvbWEiLCJ2YWxpZCIsInNjYWxlIiwibW9kZSIsIkFjdGl2aXR5Q2FsZW5kYXIiLCJkYXRhIiwiYmxvY2tNYXJnaW4iLCJibG9ja1JhZGl1cyIsImJsb2NrU2l6ZSIsImV2ZW50SGFuZGxlcnMiLCJoaWRlQ29sb3JMZWdlbmQiLCJoaWRlTW9udGhMYWJlbHMiLCJoaWRlVG90YWxDb3VudCIsImxhYmVsc1Byb3AiLCJtYXhMZXZlbCIsImxvYWRpbmciLCJyZW5kZXJCbG9jayIsInNob3dXZWVrZGF5TGFiZWxzIiwic3R5bGVQcm9wIiwidGhlbWUiLCJ0aGVtZVByb3AiLCJ0b3RhbENvdW50UHJvcCIsInN5c3RlbUNvbG9yU2NoZW1lIiwiY29sb3JTY2FsZSIsInVzZUFuaW1hdGlvbiIsImdldFllYXIiLCJPYmplY3QiLCJhc3NpZ24iLCJsYWJlbEhlaWdodCIsIndlZWtkYXlMYWJlbE9mZnNldCIsImdldERpbWVuc2lvbnMiLCJnZXRFdmVudEhhbmRsZXJzIiwia2V5cyIsImhhbmRsZXJzIiwia2V5IiwicmVuZGVyQ2FsZW5kYXIiLCJhbmltYXRpb24iLCJsb2FkaW5nQW5pbWF0aW9uIiwiYW5pbWF0aW9uRGVsYXkiLCJibG9jayIsIlJlYWN0IiwiX2V4dGVuZHMiLCJ4IiwieSIsInJ4IiwicnkiLCJGcmFnbWVudCIsInRyYW5zZm9ybSIsInJlbmRlckZvb3RlciIsInN1bSIsImNsYXNzTmFtZSIsImZvb3RlciIsIm1hcmdpbkxlZnQiLCJyZXBsYWNlIiwiU3RyaW5nIiwibGVnZW5kQ29sb3JzIiwibWFyZ2luUmlnaHQiLCJyZW5kZXJMYWJlbHMiLCJkb21pbmFudEJhc2VsaW5lIiwidGV4dEFuY2hvciIsImNvbnRhaW5lclN0eWxlcyIsImRhcmtlbiIsImhleCIsImJyaWdodGVuIiwiY29udGFpbmVyIiwic2Nyb2xsQ29udGFpbmVyIiwidmlld0JveCIsImNhbGVuZGFyIiwiU2tlbGV0b24iLCJwcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-activity-calendar/build/index.js\n");

/***/ })

};
;